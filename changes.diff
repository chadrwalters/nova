diff --git a/src/processors/image_processor.py b/src/processors/image_processor.py
index 1111111..2222222 100644
--- a/src/processors/image_processor.py
+++ b/src/processors/image_processor.py
@@ -1,8 +1,14 @@
class ImageProcessor:
def init(self, config, openai_client=None):
self.config = config
self.openai_client = openai_client
# Store a record of files that changed extensions
self.converted_files = {} # { "old_filename.ext": "new_filename.ext", ... }
def process_image(self, input_path: Path, output_dir: Path) -> Optional[ImageMetadata]:
"""
Main image processing entry point.
"""
old_str = str(input_path.name)
output_path = output_dir / input_path.name
# Example logic for HEIC -> PNG
@@ -12,11 +18,15 @@ class ImageProcessor:
# Replace .heic with .png
output_path = output_path.with_suffix('.png')
# ... do actual conversion ...
self.converted_files[old_str] = output_path.name
return ImageMetadata(processed_path=str(output_path), size=output_path.stat().st_size, ...)
# Example logic for docx -> md in case images come from docx
if input_path.suffix.lower() == '.docx':
new_md = output_path.with_suffix('.md')
# ... docx to md conversion ...
self.converted_files[old_str] = new_md.name
return ImageMetadata(processed_path=str(new_md), size=new_md.stat().st_size, ...)
# Otherwise copy unchanged
shutil.copy2(input_path, output_path)
# No extension change, so no need to record
return ImageMetadata(processed_path=str(output_path), size=output_path.stat().st_size, ...)
diff --git a/src/nova/processors/markdown_processor.py b/src/nova/processors/markdown_processor.py
index 3333333..4444444 100644
--- a/src/nova/processors/markdown_processor.py
+++ b/src/nova/processors/markdown_processor.py
@@ -1,6 +1,7 @@
class MarkdownProcessor(BaseProcessor):
def init(self, config):
super().init(config)
# We'll fix references in one pass at the end
def process_directory(self, input_dir: Path) -> None:
stats = {
@@ -45,6 +46,34 @@ class MarkdownProcessor(BaseProcessor):
# existing logic to process all files in the directory...
# images or office docs get processed and extension-changed by image_processor etc.
# After everything is processed, do a single pass to fix references:
self.fix_all_references(input_dir)
+
def fix_all_references(self, base_dir: Path) -> None:
"""
Loads each .md file under base_dir, replaces old filenames with new ones
from the image_processor's conversion map, writes back to disk.
"""
from src.processors.image_processor import ImageProcessor
# Assuming we have a single instance or you track it similarly:
# You may need to adapt this if you have multiple ImageProcessor instances.
if not hasattr(ImageProcessor, 'converted_files'):
return
+
# Gather the combined conversion map. This is a static approach; adapt if needed.
conv_map = {}
# If you've used multiple ImageProcessor instances, combine them as needed.
# Otherwise if there's a single instance, you can reference it; depends on your design.
# For demonstration, we assume it's a class-level or globally accessible object:
conv_map.update(ImageProcessor.converted_files if hasattr(ImageProcessor, 'converted_files') else {})
+
for md_file in base_dir.rglob(".md"):
content = md_file.read_text(encoding='utf-8')
for old_name, new_name in conv_map.items():
if old_name in content:
content = content.replace(old_name, new_name)
md_file.write_text(content, encoding='utf-8')
+
def process_file(self, file_path: Path) -> None:
"""
Process a single file. This can handle markdown or pass off